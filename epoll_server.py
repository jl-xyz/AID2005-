"""
基于epoll方法实现IO并发
重点代码！！！
"""

from socket import *
from select import *

#  全局变量

HOST = '0.0.0.0'
PORT = 8889
ADDR = (HOST, PORT)

# 创建tcp套接字   是监听套接字
tcp_socket = socket()
tcp_socket.bind(ADDR)
tcp_socket.listen(2)

# 设置为非阻塞
tcp_socket.setblocking(False)

p = epoll()  # 建立epoll对象
p.register(tcp_socket, EPOLLIN)  # 初始监听对象,POLLIN是关注的事件，读事件

#  准备工作，建立文件描述符和IO对象对应的字典  时刻与register的IO一致
map = {tcp_socket.fileno(): tcp_socket}  # 以文件描述符为键，以对象为值

# 循环监听
while True:
    #  对关注的IO进行监控
    events = p.poll()  # ******注意：这里不改epoll，依然使用poll*******
    print('你有新的IO需要处理哦',events)#如果某个IO就绪了，没有处理，会一直提醒
    # events--->[(fileno,event),().....]  每个元组代表一个就绪的IO
    # 第一项是就绪IO的文件秒数符，第二项是事件
    for fd, event in events:  # 用两个变量去取这个值
        #  分情况讨论
        if fd == tcp_socket.fileno():  # 监听套接字的处理
            #  处理客户端连接
            connfd, addr = map[fd].accept()  # 接收来自客户端的连接，用IO对象
            print('Connect from', addr)
            connfd.setblocking(False)  # 设置非阻塞
            p.register(connfd, EPOLLIN |EPOLLET)  # EPOLLET边缘触发，没有处理，只提醒一次
            map[connfd.fileno()] = connfd  # 同时维护字典

        # elif event == POLLIN:  # 客户端的连接套接字的处理
        #     # 收消息
        #     data = map[fd].recv(1024)
        #     if not data:
        #         # 客户端退出
        #         p.unregister(fd)  # 移除关注
        #         map[fd].close()
        #         del map[fd]  # 从字典也移除
        #         continue  # 这里使用continue，是因为这是在for循环里，如果有一个客户端退出了，此时break，其他的就都无法执行了，第一个退出了，继续取后面的
        #     print(data.decode())
        #     p.unregister(fd)  #这个register是把IO直接放入系统层，先取消，再关注
        #     p.register(fd,EPOLLOUT)  #这个register是把IO直接放入系统层
        # elif event & EPOLLOUT:
        #     map[fd].send(b'OK')
        #     p.unregister(fd)      # 先取消在关注
        #     p.register(fd,EPOLLIN)
        #

# epoll特有的触发方式
# EPOLLET


# web服务  搭建网站的后端服务，
# 网站  web开发第三阶段学的都是，为后面的内容做铺垫，原理解读
# 浏览器是一个软件，就是一个应用，google，IE，360，火狐，QQ，搜狗
# 网页是通过浏览器访问所呈现的内容
# 通过浏览器访问网页，是常事
# 这个过程中需要的重要的技术，叫做HTTP协议
# 属于访问网页的一个必要协议，是应用层协议，确定应用功能的实现方案，同时还要选择传输服务
# http协议到底实现了什么，好处是什么
# http中文翻译，超文本传输协议，可以包含很多很多数据类型，音频，视频，图片等等......
# 具备传输各种数据个数数据，这样额一个协议
# 主要功能：就是网页的获取，和数据的传输
# 初识http，熟练，爬虫还要接触
# 必须使用tcp作为数据传输的传输的服务的提供者，这是协议规定死的
# 简单灵活，很多语言都有http专门接口
# 现在研发2.0版本，目前使用得都是1.1版本
# 无状态，传输过程中不记录传输的内容，无状态会导致网页，不记录这种登录状态
# 浏览器软件自身搞的，浏览器会cookie缓存存储，浏览器这种方式就会导致网页传输不安全
# cookie密文，第三阶段后端课程
# 请求类型很丰富，聊天室，进入，聊天，退出，文件服务器，查看列表，上传下载退出等等
# http请求类型很丰富，普世性
# 可以传输的数据类型众多，也是越用越火的一个重要的原因
# 最广泛的应用，就是获取网页
# 大量的数据传输中也会使用这个协议
# 扶眼镜的手势，可以拍照，传输到后端，转化成bmp的灰度图，压缩优化整理，传给核心算法，识别出XXX，会有个及时反馈到眼镜，看到信息
# 看外文不懂，可以通过眼镜翻译，看懂，智能设备，前段，后端就是http协议

# 挑选其中一个点，网页获取来讲解
#

# 网页怎么获取到的
# 当输入www.baidu.com
# 浏览器就呈现了网页，中间经历了什么，怎么呈现的


# 浏览器  扮演了客户端角色
# 网址  自动转换成服务器的IP地址，这个过程称之为网址域名解析
# 通过IP也能够访问百度  ping www.baidu.com  61.135.169.121  使用网址登录，也就是域名，容易记忆，
# 输入网址，请求获取网络资源

# 百度服务器  百度的后端代码
# 还有一部分是前端代码，前端工程师是设计页面效果的，编写成网页文件交给后端工程师
# 后端工程师根据客户的请求，发给相关资源

# 浏览器********将请求意愿(通过输入www.baidu.com)组织为http请求格式**********
# 然后浏览器再以tcp的形式向服务端发送

# 服务器端，专门有个程序  web server ---接收请求
# 下一步对请求做一个基本的解析---解析请求
#  ----处理请求---挑好了网页组织响应
# *********将响应组织为http响应格式************
# 再以tcp发送给浏览器(客户端)

#  浏览器(客户端)---接收响应并解析，将数据展示出来


# 百度的网址就相当于一个IP，通过IP去访问，得到的是首页，可以理解为根下面的文件
# 百度服务器下面有一堆网页，按照目录结构树形的存放


# 浏览器本身还是一个解释器，会按照指定的语法进行解析，呈现网页



# http请求    组织成了什么格式给服务端发送

# 请求行   表达具体的请求类别和请求内容，独立占一行  请求类别GET  请求内容/  协议版本 hTTP/1.1
           # GET：获取网络资源，如，获取网页
           # POST：提交一定的信息，得到反馈  如登录账号
           # HEAD：只获取资源的响应头.相当于对这个资源做个描述介绍，类似目录，摘要简介类的。
           # PUT：更新服务器资源，上传资源，例如：百度网盘上传
           # DELETE：删除服务器资源.例如：百度网盘删除

           # 实际使用中，90%都是用前2种，基本都能搞定。

     #http  换行是用  \r\n 2个要一起使用

# 请求头   对请求信息的进一步解释，用键值对表示，一个键值对占一行
            # 什么时间，什么浏览器，压缩方式，什么格式等等
             # 也可以没有
# 空行

# 请求体：请求时提交时顺带提交的参数，请求体是可以没有的。

# 请求行，空行是必须要有的


# http响应
# 响应行   版本信息HTTP/1.1  响应码200  附加信息OK
# 响应码分5大类
# 1XX：请求已经接收，还没有处理
# 2XX: 响应成功
# 3XX：请求没有处理玩，需要进一步处理
# 4XX：请求客户端错误
# 5XX: 表示程序端出错

# 200   OK 纯粹的表示请求被接收了，处理也成功，可以给你网页
# 404 NOTO FIND服务器找不到请求的网页
# 500 服务器内部错误，未知的bug

# 响应头
# 通过键值对去表达的
# content -Type ：text/heml
# content -Length：109\r\n

# 空行

# 响应体  ：响应的主体内容信息







