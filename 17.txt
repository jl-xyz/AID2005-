前情回顾

1.  FTP文件服务

    请求应答

2.  IO模型

    数据在内存中的输入输出的行为
    IO: IO密集型程序特点  解决阻塞问题，提高执行效率
        CPU消耗少
        速度慢
        易阻塞

    *  阻塞IO：效率低  简单  顺序一个挨着一个来的，时常遇到阻塞

    *  非阻塞：setblocking()
              sttimeout()  超时检测

        计算密集型程序特点  搞算法
        cpu消耗多
        速度快


3.  IO多路复用
    和非阻塞一起用
    * select
      poll
    * epoll

    event & POLLTN   & 位运算符号，起到过滤的作用
    enent中是否包含POLLIN


io多路复用方法对比
         平台支持         监控IO数量    执行效率
select  优秀(全部)          1024        一般

poll    良好(Linux,unix)   无限制        一般

epoll   较差(Linux)        无限制        较高

epoll为什么效率高？对比而言的。

select poll的过程
向系统层进行IO映射对象，相当于搞了一个备份，放到了系统层
然后系统层开始帮助监控，系统轮询，不断的逐个的去访问IO
系统层感受到某个IO就绪了，会通知应用层有IO就绪，但是并没有告诉应用层是哪个IO就绪了
应用层，此时再做一次遍历，遍历出是哪个IO就绪，然后做为返回值返回，处理。

epoll有个后发优势，诞生比较晚 ，它的过程
epoll中在应用层的准备，也是在应用层准备好

poll的register就是在应用层提前整合，到底要关注哪些IO

epool的register不一样，每register一次，回自动的在系统层开辟空间，直接保存到系统层，告知系统层，要监控哪些IO
是在register那里完成的
在系统层regiser开坡系统空间存储关注的IO对象
会直接告知应用层，是哪个IO就绪了，做为返回值返回
循环回来，下一次再监控的时候，不需要再映射了，只要IO不变动了
unreigster也是直接从系统层中销毁。

epoll节省了
1，每一次监控都要不断映射一遍到系统层
2，直接给应用层节省了遍历时间
